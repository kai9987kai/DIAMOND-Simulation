<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced DIAMOND Simulation</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
        }
        h1, h2 {
            color: #333;
        }
        .canvas-container {
            display: flex;
            justify-content: space-around;
            flex-wrap: wrap;
        }
        canvas {
            border: 1px solid #ccc;
            background-color: #fff;
            margin: 10px;
        }
        .controls {
            margin-top: 20px;
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }
        .controls button, .controls input, .controls select {
            padding: 10px;
            font-size: 16px;
        }
        .info-panel {
            margin-top: 20px;
            background-color: #f9f9f9;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
        }
        #agent-path {
            stroke: red;
            stroke-width: 2;
            fill: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Advanced DIAMOND Simulation</h1>
        <div class="canvas-container">
            <div>
                <h2>World State</h2>
                <canvas id="world-canvas" width="400" height="400"></canvas>
            </div>
            <div>
                <h2>Agent's Prediction</h2>
                <canvas id="prediction-canvas" width="400" height="400"></canvas>
            </div>
        </div>
        <div class="controls">
            <button id="reset-button">Reset</button>
            <button id="step-button">Step</button>
            <button id="run-button">Run</button>
            <label for="diffusion-steps">Diffusion Steps:</label>
            <input type="number" id="diffusion-steps" value="100" min="1" max="1000">
            <label for="learning-rate">Learning Rate:</label>
            <input type="number" id="learning-rate" value="0.01" min="0.001" max="1" step="0.001">
            <label for="agent-strategy">Agent Strategy:</label>
            <select id="agent-strategy">
                <option value="random">Random</option>
                <option value="greedy">Greedy</option>
                <option value="explore">Explore</option>
            </select>
        </div>
        <div class="info-panel">
            <p>Agent Position: <span id="agent-position">(0, 0)</span></p>
            <p>Reward: <span id="reward-display">0</span></p>
            <p>Total Steps: <span id="total-steps">0</span></p>
            <p>Prediction Accuracy: <span id="prediction-accuracy">0%</span></p>
        </div>
    </div>

    <script>
        // Simulation parameters
        const GRID_SIZE = 40;
        const CELL_SIZE = 10;
        const CANVAS_SIZE = GRID_SIZE * CELL_SIZE;

        // DOM elements
        const worldCanvas = document.getElementById('world-canvas');
        const predictionCanvas = document.getElementById('prediction-canvas');
        const worldCtx = worldCanvas.getContext('2d');
        const predictionCtx = predictionCanvas.getContext('2d');
        const resetButton = document.getElementById('reset-button');
        const stepButton = document.getElementById('step-button');
        const runButton = document.getElementById('run-button');
        const diffusionStepsInput = document.getElementById('diffusion-steps');
        const learningRateInput = document.getElementById('learning-rate');
        const agentStrategySelect = document.getElementById('agent-strategy');
        const agentPositionDisplay = document.getElementById('agent-position');
        const rewardDisplay = document.getElementById('reward-display');
        const totalStepsDisplay = document.getElementById('total-steps');
        const predictionAccuracyDisplay = document.getElementById('prediction-accuracy');

        // Simulation state
        let agentPosition = [CANVAS_SIZE / 2, CANVAS_SIZE / 2];
        let reward = 0;
        let totalSteps = 0;
        let isRunning = false;
        let worldState = createInitialState();
        let predictionState = createInitialState();
        let agentPath = [];

        /**
         * Creates the initial state for the simulation.
         * @returns {number[][]} A 2D array representing the initial state.
         */
        function createInitialState() {
            const state = new Array(GRID_SIZE).fill(0).map(() => new Array(GRID_SIZE).fill(0));
            for (let i = 0; i < 5; i++) {
                const x = Math.floor(Math.random() * GRID_SIZE);
                const y = Math.floor(Math.random() * GRID_SIZE);
                state[y][x] = Math.random();
            }
            return state;
        }

        /**
         * Applies the diffusion process to the given state.
         * @param {number[][]} state - The current state.
         * @param {number} steps - The number of diffusion steps to apply.
         * @returns {number[][]} The new state after diffusion.
         */
        function diffuse(state, steps) {
            const newState = state.map(row => [...row]);
            for (let s = 0; s < steps; s++) {
                for (let y = 0; y < GRID_SIZE; y++) {
                    for (let x = 0; x < GRID_SIZE; x++) {
                        const neighbors = [
                            state[(y-1+GRID_SIZE)%GRID_SIZE][x],
                            state[(y+1)%GRID_SIZE][x],
                            state[y][(x-1+GRID_SIZE)%GRID_SIZE],
                            state[y][(x+1)%GRID_SIZE]
                        ];
                        newState[y][x] = neighbors.reduce((a, b) => a + b, 0) / 4;
                    }
                }
            }
            return newState;
        }

        /**
         * Calculates the reward based on the agent's position and the world state.
         * @param {number[]} position - The agent's position.
         * @param {number[][]} state - The current world state.
         * @returns {number} The calculated reward.
         */
        function updateReward(position, state) {
            const x = Math.floor(position[0] / CELL_SIZE);
            const y = Math.floor(position[1] / CELL_SIZE);
            return state[y][x] * 10;
        }

        /**
         * Draws the given state on the specified canvas context.
         * @param {CanvasRenderingContext2D} ctx - The canvas context to draw on.
         * @param {number[][]} state - The state to draw.
         * @param {number[]} agentPos - The agent's position.
         */
        function drawState(ctx, state, agentPos) {
            ctx.clearRect(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const intensity = Math.floor(state[y][x] * 255);
                    ctx.fillStyle = `rgb(${intensity},${intensity},${intensity})`;
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }
            ctx.fillStyle = 'red';
            ctx.beginPath();
            ctx.arc(agentPos[0], agentPos[1], 5, 0, 2 * Math.PI);
            ctx.fill();

            // Draw agent path
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
            ctx.lineWidth = 2;
            ctx.beginPath();
            agentPath.forEach((pos, index) => {
                if (index === 0) {
                    ctx.moveTo(pos[0], pos[1]);
                } else {
                    ctx.lineTo(pos[0], pos[1]);
                }
            });
            ctx.stroke();
        }

        /**
         * Updates the display with current simulation information.
         */
        function updateDisplay() {
            agentPositionDisplay.textContent = `(${Math.round(agentPosition[0])}, ${Math.round(agentPosition[1])})`;
            rewardDisplay.textContent = reward.toFixed(2);
            totalStepsDisplay.textContent = totalSteps;
            const accuracy = calculatePredictionAccuracy();
            predictionAccuracyDisplay.textContent = `${(accuracy * 100).toFixed(2)}%`;
        }

        /**
         * Calculates the prediction accuracy by comparing the world state to the prediction state.
         * @returns {number} The prediction accuracy as a value between 0 and 1.
         */
        function calculatePredictionAccuracy() {
            let totalDiff = 0;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    totalDiff += Math.abs(worldState[y][x] - predictionState[y][x]);
                }
            }
            return 1 - (totalDiff / (GRID_SIZE * GRID_SIZE));
        }

        /**
         * Moves the agent based on the selected strategy.
         */
        function moveAgent() {
            const strategy = agentStrategySelect.value;
            let dx, dy;

            switch (strategy) {
                case 'random':
                    dx = Math.random() * 20 - 10;
                    dy = Math.random() * 20 - 10;
                    break;
                case 'greedy':
                    const currentX = Math.floor(agentPosition[0] / CELL_SIZE);
                    const currentY = Math.floor(agentPosition[1] / CELL_SIZE);
                    let bestReward = predictionState[currentY][currentX];
                    let bestMove = [0, 0];

                    for (let i = -1; i <= 1; i++) {
                        for (let j = -1; j <= 1; j++) {
                            const newX = (currentX + i + GRID_SIZE) % GRID_SIZE;
                            const newY = (currentY + j + GRID_SIZE) % GRID_SIZE;
                            if (predictionState[newY][newX] > bestReward) {
                                bestReward = predictionState[newY][newX];
                                bestMove = [i, j];
                            }
                        }
                    }

                    dx = bestMove[0] * CELL_SIZE;
                    dy = bestMove[1] * CELL_SIZE;
                    break;
                case 'explore':
                    const angle = Math.random() * 2 * Math.PI;
                    dx = Math.cos(angle) * 10;
                    dy = Math.sin(angle) * 10;
                    break;
            }

            agentPosition[0] = Math.max(0, Math.min(CANVAS_SIZE - 1, agentPosition[0] + dx));
            agentPosition[1] = Math.max(0, Math.min(CANVAS_SIZE - 1, agentPosition[1] + dy));

            agentPath.push([...agentPosition]);
            if (agentPath.length > 100) {
                agentPath.shift();
            }
        }

        /**
         * Updates the prediction state based on the observed world state.
         */
        function updatePrediction() {
            const learningRate = parseFloat(learningRateInput.value);
            const x = Math.floor(agentPosition[0] / CELL_SIZE);
            const y = Math.floor(agentPosition[1] / CELL_SIZE);

            predictionState[y][x] += learningRate * (worldState[y][x] - predictionState[y][x]);
        }

        /**
         * The main update loop for the simulation.
         */
        function updateLoop() {
            const diffusionSteps = parseInt(diffusionStepsInput.value);
            worldState = diffuse(worldState, diffusionSteps);
            predictionState = diffuse(predictionState, diffusionSteps);

            moveAgent();
            updatePrediction();

            reward = updateReward(agentPosition, worldState);
            totalSteps++;

            drawState(worldCtx, worldState, agentPosition);
            drawState(predictionCtx, predictionState, agentPosition);
            updateDisplay();

            if (isRunning) {
                requestAnimationFrame(updateLoop);
            }
        }

        // Event listeners
        resetButton.addEventListener('click', () => {
            agentPosition = [CANVAS_SIZE / 2, CANVAS_SIZE / 2];
            reward = 0;
            totalSteps = 0;
            isRunning = false;
            worldState = createInitialState();
            predictionState = createInitialState();
            agentPath = [];
            drawState(worldCtx, worldState, agentPosition);
            drawState(predictionCtx, predictionState, agentPosition);
            updateDisplay();
        });

        stepButton.addEventListener('click', () => {
            if (!isRunning) {
                updateLoop();
            }
        });

        runButton.addEventListener('click', () => {
            isRunning = !isRunning;
            runButton.textContent = isRunning ? 'Stop' : 'Run';
            if (isRunning) {
                updateLoop();
            }
        });

        // Initialize
        drawState(worldCtx, worldState, agentPosition);
        drawState(predictionCtx, predictionState, agentPosition);
        updateDisplay();
    </script>
</body>
</html>
